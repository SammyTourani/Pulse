{
  "name": "Gmail to Gemini to SMS Workflow",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "simple": false,
        "filters": {
          "includeSpamTrash": false,
          "readStatus": "unread"
        },
        "format": "resolved"
      },
      "id": "gmail-trigger",
      "name": "Gmail Trigger",
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1,
      "position": [240, 300],
      "credentials": {
        "gmailOAuth2": {
          "id": "gmail-oauth",
          "name": "Gmail OAuth"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Extract and process email content with HTML-to-text conversion\nconst emailData = $input.all()[0].json;\n\n// HTML to plain text conversion function\nfunction htmlToText(html) {\n  if (!html) return '';\n  return html\n    .replace(/<style[^>]*>.*?<\\/style>/gis, '') // Remove style blocks\n    .replace(/<script[^>]*>.*?<\\/script>/gis, '') // Remove script blocks\n    .replace(/<[^>]*>/g, '') // Remove HTML tags\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\")\n    .replace(/\\s+/g, ' ') // Normalize whitespace\n    .trim();\n}\n\n// Check for large attachments (>1MB) as per requirement 1.6\nconst hasLargeAttachments = emailData.attachments && \n  emailData.attachments.some(att => att.size > 1048576);\n\n// Process email body - prioritize plain text, fallback to HTML conversion\nlet emailBody = emailData.textPlain || htmlToText(emailData.textHtml) || emailData.snippet || '';\n\n// Truncate very long emails for Gemini token limit (requirement 1.3)\nconst maxLength = 2000;\nif (emailBody.length > maxLength) {\n  emailBody = emailBody.substring(0, maxLength) + '... [truncated for processing]';\n}\n\n// Extract sender information\nconst senderName = emailData.from?.name || emailData.from?.address || 'Unknown Sender';\nconst senderEmail = emailData.from?.address || '';\n\n// Create structured prompt for Gemini API\nconst prompt = `Please write a professional email response to the following email:\n\nFrom: ${senderName} <${senderEmail}>\nSubject: ${emailData.subject}\n\nEmail content:\n${emailBody}\n\nPlease provide a concise, helpful response that addresses the sender's needs. Keep it professional and friendly. Do not include any email headers or signatures in your response - just the message body.`;\n\n// Log processing for monitoring\nconsole.log('Processing email:', {\n  messageId: emailData.id,\n  from: senderEmail,\n  subject: emailData.subject,\n  bodyLength: emailBody.length,\n  hasLargeAttachments: hasLargeAttachments,\n  timestamp: new Date().toISOString()\n});\n\nreturn {\n  json: {\n    originalEmail: {\n      messageId: emailData.id,\n      threadId: emailData.threadId,\n      from: {\n        name: senderName,\n        address: senderEmail\n      },\n      subject: emailData.subject,\n      body: emailBody,\n      hasLargeAttachments: hasLargeAttachments,\n      receivedAt: emailData.date || new Date().toISOString()\n    },\n    geminiPrompt: prompt,\n    processedAt: new Date().toISOString()\n  }\n};"
      },
      "id": "process-email",
      "name": "Process Email Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-goog-api-key",
              "value": "={{ $env.GEMINI_API_KEY }}"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={{ {\n  \"contents\": [{\n    \"parts\": [{\n      \"text\": $json.geminiPrompt\n    }]\n  }],\n  \"generationConfig\": {\n    \"temperature\": 0.7,\n    \"topK\": 40,\n    \"topP\": 0.95,\n    \"maxOutputTokens\": 1024\n  },\n  \"safetySettings\": [\n    {\n      \"category\": \"HARM_CATEGORY_HARASSMENT\",\n      \"threshold\": \"BLOCK_MEDIUM_AND_ABOVE\"\n    },\n    {\n      \"category\": \"HARM_CATEGORY_HATE_SPEECH\",\n      \"threshold\": \"BLOCK_MEDIUM_AND_ABOVE\"\n    },\n    {\n      \"category\": \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n      \"threshold\": \"BLOCK_MEDIUM_AND_ABOVE\"\n    },\n    {\n      \"category\": \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n      \"threshold\": \"BLOCK_MEDIUM_AND_ABOVE\"\n    }\n  ]\n} }}",
        "options": {
          "timeout": 3000,
          "retry": {
            "enabled": true,
            "maxTries": 2
          }
        }
      },
      "id": "gemini-api",
      "name": "Gemini API Request",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract Gemini response and prepare draft content\nconst geminiResponse = $input.all()[0].json;\nconst originalEmail = $('Process Email Content').all()[0].json.originalEmail;\n\n// Extract the generated text from Gemini response\nlet generatedResponse = '';\ntry {\n  if (geminiResponse.candidates && geminiResponse.candidates[0] && \n      geminiResponse.candidates[0].content && geminiResponse.candidates[0].content.parts) {\n    generatedResponse = geminiResponse.candidates[0].content.parts[0].text || '';\n  }\n} catch (error) {\n  console.error('Error extracting Gemini response:', error);\n  generatedResponse = 'I apologize, but I encountered an issue generating a response. Please reply manually to this email.';\n}\n\n// Clean up the response\ngeneratedResponse = generatedResponse.trim();\n\n// Add attachment note if large attachments were skipped (requirement 1.6)\nif (originalEmail.hasLargeAttachments) {\n  generatedResponse += '\\n\\nNote: Attachments from the original email were omitted from this response.';\n}\n\n// Prepare SMS notification content\nconst smsMessage = `New email draft ready:\\nFrom: ${originalEmail.from.name}\\nSubject: ${originalEmail.subject}${originalEmail.hasLargeAttachments ? '\\n(Attachments omitted)' : ''}`;\n\n// Log successful processing\nconsole.log('Gemini response processed:', {\n  messageId: originalEmail.messageId,\n  responseLength: generatedResponse.length,\n  hasLargeAttachments: originalEmail.hasLargeAttachments,\n  timestamp: new Date().toISOString()\n});\n\nreturn {\n  json: {\n    originalEmail: originalEmail,\n    draftContent: generatedResponse,\n    smsMessage: smsMessage,\n    processedAt: new Date().toISOString()\n  }\n};"
      },
      "id": "extract-response",
      "name": "Extract Gemini Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300]
    },
    {
      "parameters": {
        "resource": "draft",
        "operation": "create",
        "messageId": "={{ $json.originalEmail.messageId }}",
        "subject": "Re: {{ $json.originalEmail.subject }}",
        "message": "={{ $json.draftContent }}",
        "replyTo": "={{ $json.originalEmail.from.address }}",
        "options": {
          "threadId": "={{ $json.originalEmail.threadId }}"
        }
      },
      "id": "create-draft",
      "name": "Create Gmail Draft",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [1120, 300],
      "credentials": {
        "gmailOAuth2": {
          "id": "gmail-oauth",
          "name": "Gmail OAuth"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// SMS Rate Limiting and Validation (Requirements 3.3, 3.4, 3.5)\nconst originalEmail = $json.originalEmail;\nconst smsMessage = $json.smsMessage;\n\n// Get rate limiting configuration\nconst dailyLimit = parseInt(process.env.SMS_DAILY_LIMIT || '50');\nconst perRunLimit = parseInt(process.env.SMS_PER_RUN_LIMIT || '3');\nconst userPhone = process.env.USER_PHONE_NUMBER;\n\n// Check if user phone is configured (requirement 3.6)\nif (!userPhone) {\n  console.log('SMS notification skipped - USER_PHONE_NUMBER not configured:', {\n    messageId: originalEmail.messageId,\n    subject: originalEmail.subject,\n    timestamp: new Date().toISOString()\n  });\n  \n  return {\n    json: {\n      shouldSend: false,\n      reason: 'USER_PHONE_NUMBER not configured',\n      originalEmail: originalEmail,\n      smsMessage: smsMessage,\n      rateLimitInfo: {\n        dailyLimit: dailyLimit,\n        perRunLimit: perRunLimit,\n        currentCount: 0\n      }\n    }\n  };\n}\n\n// Get current date for daily tracking\nconst today = new Date().toISOString().split('T')[0];\nconst storageKey = `sms_count_${today}`;\n\n// Initialize or get daily SMS count from workflow memory\nlet dailyCount = 0;\ntry {\n  const stored = $workflow.getStaticData('global')[storageKey];\n  dailyCount = stored ? parseInt(stored) : 0;\n} catch (error) {\n  console.warn('Could not retrieve daily SMS count, starting from 0');\n  dailyCount = 0;\n}\n\n// Check daily limit (requirement 3.3)\nif (dailyCount >= dailyLimit) {\n  console.warn('Daily SMS limit reached:', {\n    dailyCount: dailyCount,\n    dailyLimit: dailyLimit,\n    messageId: originalEmail.messageId,\n    timestamp: new Date().toISOString()\n  });\n  \n  return {\n    json: {\n      shouldSend: false,\n      reason: 'Daily SMS limit reached',\n      originalEmail: originalEmail,\n      smsMessage: smsMessage,\n      rateLimitInfo: {\n        dailyLimit: dailyLimit,\n        perRunLimit: perRunLimit,\n        currentCount: dailyCount\n      }\n    }\n  };\n}\n\n// Update daily count\nconst newDailyCount = dailyCount + 1;\ntry {\n  $workflow.getStaticData('global')[storageKey] = newDailyCount.toString();\n} catch (error) {\n  console.warn('Could not update daily SMS count:', error.message);\n}\n\n// Log SMS sending attempt\nconsole.log('SMS notification approved:', {\n  messageId: originalEmail.messageId,\n  dailyCount: newDailyCount,\n  dailyLimit: dailyLimit,\n  userPhone: userPhone.replace(/.(?=.{4})/g, '*'),\n  timestamp: new Date().toISOString()\n});\n\nreturn {\n  json: {\n    shouldSend: true,\n    originalEmail: originalEmail,\n    smsMessage: smsMessage,\n    userPhone: userPhone,\n    rateLimitInfo: {\n      dailyLimit: dailyLimit,\n      perRunLimit: perRunLimit,\n      currentCount: newDailyCount\n    },\n    processedAt: new Date().toISOString()\n  }\n};"
      },
      "id": "sms-rate-limit",
      "name": "SMS Rate Limit Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "should-send-sms",
              "leftValue": "={{ $json.shouldSend }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "sms-gate",
      "name": "SMS Rate Limit Gate",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "message": "={{ $json.smsMessage }}",
        "toPhoneNumber": "={{ $json.userPhone }}",
        "fromPhoneNumber": "={{ $env.TWILIO_FROM_NUMBER }}",
        "options": {
          "statusCallback": ""
        }
      },
      "id": "send-sms",
      "name": "Send SMS Notification",
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [1780, 200],
      "credentials": {
        "twilioApi": {
          "id": "twilio-api",
          "name": "Twilio API"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Log SMS skip reason\nconst rateLimitInfo = $input.all()[0].json.rateLimitInfo;\nconst reason = $input.all()[0].json.reason;\n\nconsole.log('SMS notification skipped:', {\n  reason: reason,\n  currentCount: rateLimitInfo?.currentCount,\n  perRunLimit: rateLimitInfo?.perRunLimit,\n  dailyLimit: rateLimitInfo?.dailyLimit,\n  timestamp: new Date().toISOString()\n});\n\nreturn {\n  json: {\n    smsSkipped: true,\n    reason: reason,\n    rateLimitInfo: rateLimitInfo,\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "log-sms-skip",
      "name": "Log SMS Skip",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1780, 400]
    }
  ],
  "connections": {
    "Gmail Trigger": {
      "main": [
        [
          {
            "node": "Process Email Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Email Content": {
      "main": [
        [
          {
            "node": "Gemini API Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gemini API Request": {
      "main": [
        [
          {
            "node": "Extract Gemini Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Gemini Response": {
      "main": [
        [
          {
            "node": "Create Gmail Draft",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Gmail Draft": {
      "main": [
        [
          {
            "node": "SMS Rate Limit Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SMS Rate Limit Check": {
      "main": [
        [
          {
            "node": "SMS Rate Limit Gate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SMS Rate Limit Gate": {
      "main": [
        [
          {
            "node": "Send SMS Notification",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log SMS Skip",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "versionId": "1",
  "meta": {
    "templateCredsSetupCompleted": false
  },
  "id": "gmail-gemini-workflow",
  "tags": [
    {
      "createdAt": "2025-01-26T00:00:00.000Z",
      "updatedAt": "2025-01-26T00:00:00.000Z",
      "id": "pulse-ai",
      "name": "pulse-ai"
    }
  ]
}