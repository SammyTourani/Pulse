{
  "name": "brick_error_handler",
  "nodes": [
    {
      "parameters": {},
      "id": "start-node",
      "name": "When called by another workflow",
      "type": "n8n-nodes-base.start",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "jsCode": "// Enhanced error handler for brick workflows with retry logic awareness\n// Requirements: 8.1, 8.2, 8.3\n\n// Import retry utilities for error classification\nconst { isGmailErrorRetryable, isCalendarErrorRetryable, isGeminiErrorRetryable } = require('./flows/bricks/brick-retry-utils.js');\n\ntry {\n  const inputData = $input.all()[0].json;\n  \n  console.log('[INFO] Brick Error Handler: Processing error with retry context', {\n    brickName: inputData.brickName,\n    errorCode: inputData.error?.code,\n    httpStatus: inputData.error?.httpStatus,\n    hasContext: !!inputData.context,\n    timestamp: new Date().toISOString()\n  });\n  \n  // Determine if the error was retryable based on brick type and error details\n  let wasRetryable = false;\n  const brickName = inputData.brickName || 'unknown';\n  const error = inputData.error;\n  \n  if (error) {\n    // Check retryability based on brick type\n    if (brickName.includes('email') || brickName.includes('gmail')) {\n      wasRetryable = isGmailErrorRetryable(error);\n    } else if (brickName.includes('calendar')) {\n      wasRetryable = isCalendarErrorRetryable(error);\n    } else if (brickName.includes('gemini') || brickName.includes('summarize')) {\n      wasRetryable = isGeminiErrorRetryable(error);\n    }\n  }\n  \n  // Enhanced error response with retry context\n  const errorResponse = {\n    ok: false,\n    error: error?.message || 'Unknown error occurred',\n    code: error?.code || 'UNKNOWN_ERROR',\n    timestamp: new Date().toISOString(),\n    brick: brickName,\n    requestId: generateRequestId(),\n    retryContext: {\n      wasRetryable: wasRetryable,\n      retryAttempted: error?.retryAttempted || false,\n      maxRetries: error?.maxRetries || 0,\n      retryLogic: inputData.context?.retryLogic || 'none'\n    },\n    context: inputData.context || {}\n  };\n  \n  // Set appropriate HTTP status\n  const httpStatus = error?.httpStatus || 500;\n  \n  console.log('[ERROR] Brick Error Handler: Formatted error response', {\n    brickName: brickName,\n    errorCode: errorResponse.code,\n    httpStatus: httpStatus,\n    wasRetryable: wasRetryable,\n    retryAttempted: error?.retryAttempted || false,\n    timestamp: new Date().toISOString()\n  });\n  \n  // Return error response with HTTP status\n  return {\n    json: errorResponse,\n    httpStatus: httpStatus\n  };\n  \n} catch (handlerError) {\n  console.error('[CRITICAL] Error in brick error handler:', {\n    error: handlerError.message,\n    stack: handlerError.stack,\n    timestamp: new Date().toISOString()\n  });\n  \n  // Fallback error response\n  return {\n    json: {\n      ok: false,\n      error: 'Critical error in error handling system',\n      code: 'ERROR_HANDLER_FAILURE',\n      timestamp: new Date().toISOString(),\n      brick: 'error_handler',\n      requestId: generateRequestId()\n    },\n    httpStatus: 500\n  };\n}\n\n// Helper function to generate request ID\nfunction generateRequestId() {\n  return 'req_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);\n}"
      },
      "id": "process-error",
      "name": "Process Error with Retry Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    }
  ],
  "connections": {
    "When called by another workflow": {
      "main": [
        [
          {
            "node": "Process Error with Retry Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": {},
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "1"
}