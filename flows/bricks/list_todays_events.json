{
  "name": "list_todays_events",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "webhook-brick/list_todays_events",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        240,
        300
      ],
      "webhookId": "list-todays-events-webhook"
    },
    {
      "parameters": {
        "workflowId": "brick_auth_guard"
      },
      "id": "call-auth-guard",
      "name": "Call Auth Guard",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [
        460,
        300
      ]
    },
    {
      "parameters": {
        "jsCode": "// Check MOCK_MODE and prepare business logic\nconst inputData = $input.all()[0].json;\nconst mockMode = process.env.MOCK_MODE === 'true';\nconst genericTimezone = process.env.GENERIC_TIMEZONE || 'UTC';\n\n// Privacy-compliant logging function\nfunction logWithPrivacy(level, message, data = {}) {\n  const sanitizedData = { ...data };\n  // Mask email addresses for privacy\n  if (sanitizedData.attendees && Array.isArray(sanitizedData.attendees)) {\n    sanitizedData.attendees = sanitizedData.attendees.map(() => '***@***');\n  }\n  console.log(`[${level.toUpperCase()}] List Today's Events: ${message}`, sanitizedData);\n}\n\nlogWithPrivacy('info', 'Processing list_todays_events request', {\n  mockMode: mockMode,\n  timezone: genericTimezone,\n  timestamp: new Date().toISOString()\n});\n\nif (mockMode) {\n  // Return mock response with sample events\n  const mockEvents = [\n    {\n      title: \"Team Standup\",\n      start: \"2024-01-15T09:00:00.000Z\",\n      end: \"2024-01-15T09:30:00.000Z\",\n      location: \"Conference Room A\",\n      attendees: [\"***@***\", \"***@***\"]\n    },\n    {\n      title: \"Project Review\",\n      start: \"2024-01-15T14:00:00.000Z\",\n      end: \"2024-01-15T15:00:00.000Z\",\n      location: \"Virtual Meeting\",\n      attendees: [\"***@***\"]\n    },\n    {\n      title: \"Client Call\",\n      start: \"2024-01-15T16:30:00.000Z\",\n      end: \"2024-01-15T17:30:00.000Z\",\n      location: \"\",\n      attendees: []\n    }\n  ];\n  \n  logWithPrivacy('info', 'MOCK MODE: Returning sample events', {\n    eventCount: mockEvents.length,\n    timezone: genericTimezone\n  });\n  \n  return {\n    json: {\n      brickName: 'list_todays_events',\n      success: true,\n      data: {\n        events: mockEvents\n      },\n      originalInput: inputData.body || {},\n      mockMode: true\n    }\n  };\n}\n\n// Calculate today's date range in the specified timezone\nconst now = new Date();\nconst today = new Date(now.toLocaleString(\"en-US\", {timeZone: genericTimezone}));\ntoday.setHours(0, 0, 0, 0);\n\nconst tomorrow = new Date(today);\ntomorrow.setDate(tomorrow.getDate() + 1);\n\n// Convert back to UTC for Google Calendar API\nconst timeMin = today.toISOString();\nconst timeMax = tomorrow.toISOString();\n\nlogWithPrivacy('info', 'Calculated today\\'s date range', {\n  timezone: genericTimezone,\n  timeMin: timeMin,\n  timeMax: timeMax,\n  localDate: today.toISOString().split('T')[0]\n});\n\n// Prepare for real Google Calendar API call\nreturn {\n  json: {\n    brickName: 'list_todays_events',\n    originalInput: inputData.body || {},\n    mockMode: false,\n    timeMin: timeMin,\n    timeMax: timeMax,\n    timezone: genericTimezone,\n    startTime: Date.now()\n  }\n};"
      },
      "id": "check-mock-mode",
      "name": "Check Mock Mode & Prepare",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        680,
        300
      ]
    },
    {
      "parameters": {
        "resource": "event",
        "operation": "getAll",
        "calendarId": "={{ process.env.GOOGLE_CALENDAR_ID || 'primary' }}",
        "options": {
          "timeMin": "={{ $json.timeMin }}",
          "timeMax": "={{ $json.timeMax }}",
          "singleEvents": true,
          "orderBy": "startTime"
        }
      },
      "id": "list-calendar-events",
      "name": "List Calendar Events",
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1,
      "position": [
        1120,
        420
      ],
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "google-calendar-oauth",
          "name": "Google Calendar OAuth"
        }
      },
      "continueOnFail": true,
      "retryOnFail": true,
      "maxTries": 5,
      "waitBetween": 2000
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Google Calendar API response processing with retry logic awareness\n// Requirements: 5.2, 11.1, 12.1\n// Note: Retry logic is handled by the n8n node configuration (maxTries: 5, waitBetween: 2000)\n\ntry {\n  const inputData = $input.all()[0].json;\n  const previousData = $input.all()[1]?.json || {};\n  \n  // Privacy-compliant logging function\n  function logWithPrivacy(level, message, data = {}) {\n    const sanitizedData = { ...data };\n    // Mask email addresses for privacy\n    if (sanitizedData.events && Array.isArray(sanitizedData.events)) {\n      sanitizedData.events = sanitizedData.events.map(event => ({\n        ...event,\n        attendees: event.attendees ? event.attendees.map(() => '***@***') : []\n      }));\n    }\n    console.log(`[${level.toUpperCase()}] List Today's Events Processing: ${message}`, sanitizedData);\n  }\n  \n  logWithPrivacy('info', 'Processing Google Calendar API response', {\n    hasError: !!inputData.error,\n    isArray: Array.isArray(inputData),\n    dataType: typeof inputData\n  });\n  \n  // Check if Google Calendar API call was successful\n  if (inputData.error) {\n    // Determine error type and appropriate HTTP status\n    let httpStatus = 502; // Default to bad gateway\n    let errorCode = 'CALENDAR_API_ERROR';\n    let errorMessage = 'Google Calendar API error';\n    \n    if (typeof inputData.error === 'object') {\n      const error = inputData.error;\n      \n      // Handle specific Google Calendar API errors\n      if (error.code) {\n        switch (error.code) {\n          case 400:\n            httpStatus = 400;\n            errorCode = 'CALENDAR_BAD_REQUEST';\n            errorMessage = 'Invalid request to Calendar API';\n            break;\n          case 401:\n            httpStatus = 502;\n            errorCode = 'CALENDAR_AUTH_ERROR';\n            errorMessage = 'Google Calendar authentication failed';\n            break;\n          case 403:\n            httpStatus = 502;\n            errorCode = 'CALENDAR_PERMISSION_ERROR';\n            errorMessage = 'Insufficient permissions for Google Calendar API';\n            break;\n          case 429:\n            httpStatus = 503;\n            errorCode = 'CALENDAR_RATE_LIMITED';\n            errorMessage = 'Google Calendar API rate limit exceeded';\n            break;\n          case 500:\n          case 502:\n          case 503:\n            httpStatus = 502;\n            errorCode = 'CALENDAR_SERVER_ERROR';\n            errorMessage = 'Google Calendar API server error';\n            break;\n          default:\n            errorMessage = error.message || 'Unknown Google Calendar API error';\n        }\n      } else {\n        errorMessage = error.message || error.toString();\n      }\n    } else {\n      errorMessage = inputData.error.toString();\n    }\n    \n    logWithPrivacy('error', 'Google Calendar API call failed', {\n      errorCode: errorCode,\n      httpStatus: httpStatus,\n      errorMessage: errorMessage\n    });\n    \n    return {\n      json: {\n        brickName: 'list_todays_events',\n        success: false,\n        error: errorMessage,\n        code: errorCode,\n        httpStatus: httpStatus,\n        originalInput: previousData.originalInput\n      }\n    };\n  }\n  \n  // Process the events array from Google Calendar API\n  let events = [];\n  \n  // Handle different response formats from Google Calendar API\n  if (Array.isArray(inputData)) {\n    events = inputData;\n  } else if (inputData.items && Array.isArray(inputData.items)) {\n    events = inputData.items;\n  } else if (typeof inputData === 'object' && inputData !== null) {\n    // Single event or unexpected format\n    events = [inputData];\n  }\n  \n  logWithPrivacy('info', 'Processing calendar events', {\n    rawEventCount: events.length,\n    timezone: previousData.timezone || 'UTC'\n  });\n  \n  // Format events into standardized response structure\n  const formattedEvents = [];\n  const genericTimezone = previousData.timezone || 'UTC';\n  \n  for (const event of events) {\n    try {\n      // Skip events without required fields\n      if (!event.summary && !event.start) {\n        continue;\n      }\n      \n      // Extract start and end times\n      let startTime, endTime;\n      \n      if (event.start) {\n        if (event.start.dateTime) {\n          startTime = new Date(event.start.dateTime).toISOString();\n        } else if (event.start.date) {\n          // All-day event\n          startTime = new Date(event.start.date + 'T00:00:00.000Z').toISOString();\n        }\n      }\n      \n      if (event.end) {\n        if (event.end.dateTime) {\n          endTime = new Date(event.end.dateTime).toISOString();\n        } else if (event.end.date) {\n          // All-day event\n          endTime = new Date(event.end.date + 'T23:59:59.999Z').toISOString();\n        }\n      }\n      \n      // Skip events without valid times\n      if (!startTime) {\n        continue;\n      }\n      \n      // Format attendees with privacy masking\n      let attendees = [];\n      if (event.attendees && Array.isArray(event.attendees)) {\n        attendees = event.attendees\n          .filter(attendee => attendee.email)\n          .map(() => '***@***'); // Privacy-compliant masking\n      }\n      \n      const formattedEvent = {\n        title: event.summary || 'Untitled Event',\n        start: startTime,\n        end: endTime || startTime, // Use start time if end time is missing\n        location: event.location || '',\n        attendees: attendees\n      };\n      \n      formattedEvents.push(formattedEvent);\n      \n    } catch (eventError) {\n      logWithPrivacy('warn', 'Skipping malformed event', {\n        eventId: event.id,\n        error: eventError.message\n      });\n      continue;\n    }\n  }\n  \n  // Sort events by start time\n  formattedEvents.sort((a, b) => new Date(a.start) - new Date(b.start));\n  \n  logWithPrivacy('info', 'Calendar events processed successfully', {\n    totalEvents: formattedEvents.length,\n    timezone: genericTimezone,\n    dateRange: {\n      from: previousData.timeMin,\n      to: previousData.timeMax\n    },\n    timestamp: new Date().toISOString()\n  });\n  \n  // Return successful response\n  return {\n    json: {\n      brickName: 'list_todays_events',\n      success: true,\n      data: {\n        events: formattedEvents\n      },\n      originalInput: previousData.originalInput,\n      duration: Date.now() - (previousData.startTime || Date.now())\n    }\n  };\n  \n} catch (error) {\n  // Handle unexpected errors in response processing\n  console.error('[ERROR] Unexpected error in Calendar events processing:', {\n    error: error.message,\n    stack: error.stack,\n    timestamp: new Date().toISOString()\n  });\n  \n  return {\n    json: {\n      brickName: 'list_todays_events',\n      success: false,\n      error: 'Internal error processing Calendar events',\n      code: 'INTERNAL_PROCESSING_ERROR',\n      httpStatus: 500,\n      originalInput: ($input.all()[1]?.json || {}).originalInput\n    }\n  };\n}"
      },
      "id": "process-calendar-response",
      "name": "Process Calendar Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1340,
        420
      ]
    },
    {
      "parameters": {
        "jsCode": "// Format success response directly\nconst inputData = $input.all()[0].json;\nconst requestId = 'req_' + Date.now().toString(36) + '_' + Math.random().toString(36).substr(2, 9);\n\nconst response = {\n  ok: true,\n  data: inputData.data,  brick: 'list_todays_events',\n  timestamp: new Date().toISOString(),\n  requestId: requestId\n};\n\nreturn {\n  json: {\n    response: response,\n    httpStatus: 200\n  }\n};"
      },
      "id": "format-success-response",
      "name": "Format Success Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1560,
        420
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json.response }}",
        "options": {
          "responseCode": "={{ $json.httpStatus }}"
        }
      },
      "id": "send-success-response",
      "name": "Send Success Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1780,
        420
      ]
    },
    {
      "parameters": {},
      "id": "start-node",
      "name": "When called by another workflow",
      "type": "n8n-nodes-base.start",
      "typeVersion": 1,
      "position": [
        240,
        500
      ]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Call Auth Guard",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When called by another workflow": {
      "main": [
        [
          {
            "node": "Check Mock Mode & Prepare",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Call Auth Guard": {
      "main": [
        [
          {
            "node": "Check Mock Mode & Prepare",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Mock Mode & Prepare": {
      "main": [
        [
          {
            "node": "Mock Mode?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Mock Mode?": {
      "main": [
        [
          {
            "node": "Call Respond (Mock)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "List Calendar Events",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "List Calendar Events": {
      "main": [
        [
          {
            "node": "Process Calendar Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Calendar Response": {
      "main": [
        [
          {
            "node": "Call Respond (Real)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "format-error-response": {
      "main": [
        [
          {
            "node": "send-error-response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "format-success-response": {
      "main": [
        [
          {
            "node": "send-success-response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": {},
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "1"
}