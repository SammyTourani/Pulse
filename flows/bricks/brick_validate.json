{
  "name": "brick_validate",
  "nodes": [
    {
      "parameters": {},
      "id": "start-node",
      "name": "Start",
      "type": "n8n-nodes-base.start",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract brick name and input data from the calling workflow\nconst inputData = $input.all()[0].json;\nconst brickName = inputData.brickName;\nconst inputToValidate = inputData.inputData;\n\n// Define validation schemas for each brick type\nconst validationSchemas = {\n  create_email_draft: {\n    type: 'object',\n    properties: {\n      to: { type: 'string', format: 'email' },\n      subject: { type: 'string', minLength: 1 },\n      body: { type: 'string', minLength: 1 }\n    },\n    required: ['to', 'subject', 'body'],\n    additionalProperties: false\n  },\n  \n  summarize_emails: {\n    type: 'object',\n    properties: {\n      sinceISO: { type: 'string', format: 'date-time' }\n    },\n    required: ['sinceISO'],\n    additionalProperties: false\n  },\n  \n  create_calendar_event: {\n    type: 'object',\n    properties: {\n      title: { type: 'string', minLength: 1 },\n      startISO: { type: 'string', format: 'date-time' },\n      endISO: { type: 'string', format: 'date-time' },\n      guests: { \n        type: 'array', \n        items: { type: 'string', format: 'email' },\n        uniqueItems: true\n      },\n      description: { type: 'string' },\n      location: { type: 'string' }\n    },\n    required: ['title', 'startISO', 'endISO'],\n    additionalProperties: false\n  },\n  \n  list_todays_events: {\n    type: 'object',\n    properties: {},\n    additionalProperties: false\n  }\n};\n\n// Get schema for the brick\nconst schema = validationSchemas[brickName];\nif (!schema) {\n  return {\n    json: {\n      validationResult: 'schema_not_found',\n      response: {\n        ok: false,\n        error: `Unknown brick type: ${brickName}`,\n        code: 'VALIDATION_SCHEMA_NOT_FOUND',\n        timestamp: new Date().toISOString()\n      },\n      httpStatus: 400\n    }\n  };\n}\n\n// Validation helper functions\nfunction validateType(value, expectedType) {\n  switch (expectedType) {\n    case 'string':\n      return typeof value === 'string';\n    case 'number':\n      return typeof value === 'number' && !isNaN(value);\n    case 'boolean':\n      return typeof value === 'boolean';\n    case 'array':\n      return Array.isArray(value);\n    case 'object':\n      return typeof value === 'object' && value !== null && !Array.isArray(value);\n    default:\n      return false;\n  }\n}\n\nfunction validateEmail(email) {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\nfunction validateISO8601(dateString) {\n  const iso8601Regex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?Z?$/;\n  if (!iso8601Regex.test(dateString)) return false;\n  \n  const date = new Date(dateString);\n  return date instanceof Date && !isNaN(date.getTime());\n}\n\n// Perform validation\nconst errors = [];\n\n// Check if input is an object\nif (!validateType(inputToValidate, 'object')) {\n  errors.push('Input must be a JSON object');\n} else {\n  // Check required fields\n  if (schema.required) {\n    for (const requiredField of schema.required) {\n      if (!(requiredField in inputToValidate)) {\n        errors.push(`Missing required field: ${requiredField}`);\n      }\n    }\n  }\n  \n  // Check additional properties\n  if (schema.additionalProperties === false) {\n    const allowedProperties = Object.keys(schema.properties || {});\n    for (const prop in inputToValidate) {\n      if (!allowedProperties.includes(prop)) {\n        errors.push(`Unknown property: ${prop}`);\n      }\n    }\n  }\n  \n  // Validate each property\n  for (const [propName, propSchema] of Object.entries(schema.properties || {})) {\n    const value = inputToValidate[propName];\n    \n    if (value !== undefined) {\n      // Type validation\n      if (!validateType(value, propSchema.type)) {\n        errors.push(`Field '${propName}' must be of type ${propSchema.type}`);\n        continue;\n      }\n      \n      // Format validation\n      if (propSchema.format) {\n        switch (propSchema.format) {\n          case 'email':\n            if (!validateEmail(value)) {\n              errors.push(`Field '${propName}' must be a valid email address`);\n            }\n            break;\n          case 'date-time':\n            if (!validateISO8601(value)) {\n              errors.push(`Field '${propName}' must be a valid ISO 8601 date-time string`);\n            }\n            break;\n        }\n      }\n      \n      // String length validation\n      if (propSchema.type === 'string' && propSchema.minLength && value.length < propSchema.minLength) {\n        errors.push(`Field '${propName}' must be at least ${propSchema.minLength} characters long`);\n      }\n      \n      // Array validation\n      if (propSchema.type === 'array' && propSchema.items) {\n        for (let i = 0; i < value.length; i++) {\n          const item = value[i];\n          if (!validateType(item, propSchema.items.type)) {\n            errors.push(`Array item ${i} in field '${propName}' must be of type ${propSchema.items.type}`);\n          } else if (propSchema.items.format === 'email' && !validateEmail(item)) {\n            errors.push(`Array item ${i} in field '${propName}' must be a valid email address`);\n          }\n        }\n        \n        // Unique items validation\n        if (propSchema.uniqueItems && new Set(value).size !== value.length) {\n          errors.push(`Field '${propName}' must contain unique items`);\n        }\n      }\n    }\n  }\n}\n\n// Return validation result\nif (errors.length > 0) {\n  return {\n    json: {\n      validationResult: 'failed',\n      response: {\n        ok: false,\n        error: 'Input validation failed',\n        code: 'VALIDATION_FAILED',\n        details: errors,\n        timestamp: new Date().toISOString()\n      },\n      httpStatus: 400\n    }\n  };\n}\n\nreturn {\n  json: {\n    validationResult: 'passed',\n    message: 'Input validation passed',\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "validate-input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "validation-failed",
              "leftValue": "={{ $json.validationResult }}",
              "rightValue": "passed",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "validation-branch",
      "name": "Validation Failed?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json.response }}",
        "options": {
          "responseCode": "={{ $json.httpStatus }}"
        }
      },
      "id": "validation-error-response",
      "name": "Return Validation Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [900, 180]
    },
    {
      "parameters": {
        "jsCode": "// Validation passed\n// Return success indicator for the calling workflow\nreturn {\n  json: {\n    validationSuccess: true,\n    message: 'Input validation passed',\n    timestamp: new Date().toISOString()\n  }\n};"
      },
      "id": "validation-success",
      "name": "Validation Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 420]
    }
  ],
  "connections": {
    "Start": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Validation Failed?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validation Failed?": {
      "main": [
        [
          {
            "node": "Return Validation Error",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Validation Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": {},
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2024-01-01T00:00:00.000Z",
  "versionId": "1"
}