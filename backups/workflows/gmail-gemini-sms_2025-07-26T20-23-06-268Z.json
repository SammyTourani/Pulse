{
  "name": "Gmail to Gemini to SMS Workflow (Enhanced Error Handling)",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "everyMinute"
            }
          ]
        },
        "simple": false,
        "filters": {
          "includeSpamTrash": false,
          "readStatus": "unread"
        },
        "format": "resolved"
      },
      "id": "gmail-trigger",
      "name": "Gmail Trigger",
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1,
      "position": [240, 300],
      "credentials": {
        "gmailOAuth2": {
          "id": "gmail-oauth",
          "name": "Gmail OAuth"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Email Processing with Error Handling\n// Requirements: 5.1, 5.2, 5.3, 5.4, 5.5\n\n// Import error handling utilities\nconst { logWithContext, handleWorkflowError, sanitizeForLogging, TokenTracker } = require('./error-handling-utils.js');\n\ntry {\n  const emailData = $input.all()[0].json;\n  const nodeName = 'Process Email Content';\n  \n  logWithContext('info', nodeName, 'Starting email processing', {\n    messageId: emailData.id,\n    from: sanitizeForLogging({ address: emailData.from?.address }),\n    subject: emailData.subject\n  });\n\n  // HTML to plain text conversion function with error handling\n  function htmlToText(html) {\n    try {\n      if (!html) return '';\n      return html\n        .replace(/<style[^>]*>.*?<\\/style>/gis, '') // Remove style blocks\n        .replace(/<script[^>]*>.*?<\\/script>/gis, '') // Remove script blocks\n        .replace(/<[^>]*>/g, '') // Remove HTML tags\n        .replace(/&nbsp;/g, ' ')\n        .replace(/&amp;/g, '&')\n        .replace(/&lt;/g, '<')\n        .replace(/&gt;/g, '>')\n        .replace(/&quot;/g, '\"')\n        .replace(/&#39;/g, \"'\")\n        .replace(/\\s+/g, ' ') // Normalize whitespace\n        .trim();\n    } catch (error) {\n      logWithContext('warn', nodeName, 'HTML to text conversion failed, using fallback', {\n        error: error.message\n      });\n      return html || '';\n    }\n  }\n\n  // Validate email data structure\n  if (!emailData || !emailData.id) {\n    throw new Error('Invalid email data structure received');\n  }\n\n  // Check for large attachments (>1MB) as per requirement 1.6\n  let hasLargeAttachments = false;\n  try {\n    hasLargeAttachments = emailData.attachments && \n      emailData.attachments.some(att => att.size > 1048576);\n  } catch (error) {\n    logWithContext('warn', nodeName, 'Error checking attachments', {\n      error: error.message\n    });\n  }\n\n  // Process email body - prioritize plain text, fallback to HTML conversion\n  let emailBody = '';\n  try {\n    emailBody = emailData.textPlain || \n                htmlToText(emailData.textHtml) || \n                emailData.snippet || \n                '';\n  } catch (error) {\n    logWithContext('warn', nodeName, 'Error processing email body', {\n      error: error.message\n    });\n    emailBody = emailData.snippet || 'Unable to process email content';\n  }\n\n  // Truncate very long emails for Gemini token limit (requirement 1.3)\n  const maxLength = 2000;\n  if (emailBody.length > maxLength) {\n    emailBody = emailBody.substring(0, maxLength) + '... [truncated for processing]';\n    logWithContext('info', nodeName, 'Email body truncated for token limit', {\n      originalLength: emailBody.length + (maxLength - 2000),\n      truncatedLength: emailBody.length\n    });\n  }\n\n  // Extract sender information safely\n  let senderName = 'Unknown Sender';\n  let senderEmail = '';\n  try {\n    senderName = emailData.from?.name || emailData.from?.address || 'Unknown Sender';\n    senderEmail = emailData.from?.address || '';\n  } catch (error) {\n    logWithContext('warn', nodeName, 'Error extracting sender information', {\n      error: error.message\n    });\n  }\n\n  // Create structured prompt for Gemini API\n  const prompt = `Please write a professional email response to the following email:\n\nFrom: ${senderName} <${senderEmail}>\nSubject: ${emailData.subject}\n\nEmail content:\n${emailBody}\n\nPlease provide a concise, helpful response that addresses the sender's needs. Keep it professional and friendly. Do not include any email headers or signatures in your response - just the message body.`;\n\n  // Initialize token tracker\n  const tokenTracker = new TokenTracker();\n  let tokenInfo;\n  try {\n    tokenInfo = tokenTracker.checkAndUpdateTokens(prompt);\n  } catch (error) {\n    logWithContext('error', nodeName, 'Token limit check failed', {\n      error: error.message\n    });\n    throw error;\n  }\n\n  // Log successful processing\n  logWithContext('info', nodeName, 'Email processing completed successfully', {\n    messageId: emailData.id,\n    bodyLength: emailBody.length,\n    hasLargeAttachments: hasLargeAttachments,\n    tokenEstimate: tokenInfo.inputTokens,\n    processedAt: new Date().toISOString()\n  });\n\n  return {\n    json: {\n      originalEmail: {\n        messageId: emailData.id,\n        threadId: emailData.threadId,\n        from: {\n          name: senderName,\n          address: senderEmail\n        },\n        subject: emailData.subject,\n        body: emailBody,\n        hasLargeAttachments: hasLargeAttachments,\n        receivedAt: emailData.date || new Date().toISOString()\n      },\n      geminiPrompt: prompt,\n      tokenInfo: tokenInfo,\n      processedAt: new Date().toISOString(),\n      error: false\n    }\n  };\n\n} catch (error) {\n  const errorResponse = handleWorkflowError(error, 'Process Email Content', {\n    inputData: sanitizeForLogging($input.all()[0]?.json)\n  });\n  \n  return {\n    json: {\n      ...errorResponse,\n      originalEmail: {\n        messageId: 'unknown',\n        threadId: 'unknown',\n        from: { name: 'Unknown', address: 'unknown' },\n        subject: 'Processing Error',\n        body: 'Error processing email content',\n        hasLargeAttachments: false,\n        receivedAt: new Date().toISOString()\n      },\n      geminiPrompt: 'Error: Unable to process email for Gemini API',\n      processedAt: new Date().toISOString()\n    }\n  };\n}"
      },
      "id": "process-email",
      "name": "Process Email Content",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Gemini API Request with Comprehensive Error Handling\n// Requirements: 5.1, 5.2, 5.3, 5.4, 5.5\n\nconst { logWithContext, handleGeminiAPICall, handleWorkflowError, sanitizeForLogging } = require('./error-handling-utils.js');\n\ntry {\n  const inputData = $input.all()[0].json;\n  const nodeName = 'Gemini API Request';\n  \n  // Check if previous node had an error\n  if (inputData.error) {\n    logWithContext('warn', nodeName, 'Skipping Gemini API call due to upstream error', {\n      upstreamError: inputData.message\n    });\n    \n    return {\n      json: {\n        ...inputData,\n        geminiResponse: {\n          candidates: [{\n            content: {\n              parts: [{\n                text: 'I apologize, but I encountered an issue processing your email. Please reply manually to this message.'\n              }]\n            }\n          }]\n        },\n        apiCallSkipped: true,\n        processedAt: new Date().toISOString()\n      }\n    };\n  }\n\n  const apiKey = process.env.GEMINI_API_KEY;\n  if (!apiKey) {\n    throw new Error('GEMINI_API_KEY environment variable not set');\n  }\n\n  logWithContext('info', nodeName, 'Starting Gemini API request', {\n    messageId: inputData.originalEmail?.messageId,\n    tokenEstimate: inputData.tokenInfo?.inputTokens\n  });\n\n  // Prepare request body\n  const requestBody = {\n    contents: [{\n      parts: [{\n        text: inputData.geminiPrompt\n      }]\n    }],\n    generationConfig: {\n      temperature: 0.7,\n      topK: 40,\n      topP: 0.95,\n      maxOutputTokens: 1024\n    },\n    safetySettings: [\n      {\n        category: \"HARM_CATEGORY_HARASSMENT\",\n        threshold: \"BLOCK_MEDIUM_AND_ABOVE\"\n      },\n      {\n        category: \"HARM_CATEGORY_HATE_SPEECH\",\n        threshold: \"BLOCK_MEDIUM_AND_ABOVE\"\n      },\n      {\n        category: \"HARM_CATEGORY_SEXUALLY_EXPLICIT\",\n        threshold: \"BLOCK_MEDIUM_AND_ABOVE\"\n      },\n      {\n        category: \"HARM_CATEGORY_DANGEROUS_CONTENT\",\n        threshold: \"BLOCK_MEDIUM_AND_ABOVE\"\n      }\n    ]\n  };\n\n  // Make API call with enhanced error handling\n  const response = await handleGeminiAPICall(async () => {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout\n\n    try {\n      const response = await fetch(\n        'https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent',\n        {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'x-goog-api-key': apiKey\n          },\n          body: JSON.stringify(requestBody),\n          signal: controller.signal\n        }\n      );\n\n      clearTimeout(timeoutId);\n      return response;\n    } catch (error) {\n      clearTimeout(timeoutId);\n      throw error;\n    }\n  });\n\n  const responseData = await response.json();\n  \n  logWithContext('info', nodeName, 'Gemini API request completed successfully', {\n    messageId: inputData.originalEmail?.messageId,\n    responseStatus: response.status,\n    hasResponse: !!(responseData.candidates && responseData.candidates[0])\n  });\n\n  return {\n    json: {\n      ...inputData,\n      geminiResponse: responseData,\n      apiCallSuccess: true,\n      responseTime: Date.now() - (inputData.processedAt ? new Date(inputData.processedAt).getTime() : Date.now()),\n      processedAt: new Date().toISOString(),\n      error: false\n    }\n  };\n\n} catch (error) {\n  const errorResponse = handleWorkflowError(error, 'Gemini API Request', {\n    inputData: sanitizeForLogging($input.all()[0]?.json)\n  });\n  \n  // Return fallback response structure\n  return {\n    json: {\n      ...$input.all()[0].json,\n      ...errorResponse,\n      geminiResponse: {\n        candidates: [{\n          content: {\n            parts: [{\n              text: 'I apologize, but I encountered an issue generating a response. Please reply manually to this email.'\n            }]\n          }\n        }]\n      },\n      apiCallSuccess: false,\n      processedAt: new Date().toISOString()\n    }\n  };\n}"
      },
      "id": "gemini-api",
      "name": "Gemini API Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [680, 300],
      "onError": "continueRegularOutput"
    },

    {
      "parameters": {
        "jsCode": "// Enhanced Response Extraction with Error Handling\n// Requirements: 5.1, 5.2, 5.3, 5.4, 5.5\n\nconst { logWithContext, handleWorkflowError, sanitizeForLogging, TokenTracker } = require('./error-handling-utils.js');\n\ntry {\n  const inputData = $input.all()[0].json;\n  const nodeName = 'Extract Gemini Response';\n  \n  logWithContext('info', nodeName, 'Starting response extraction', {\n    messageId: inputData.originalEmail?.messageId,\n    hasGeminiResponse: !!(inputData.geminiResponse)\n  });\n\n  // Check if previous nodes had errors\n  if (inputData.error && !inputData.apiCallSkipped) {\n    logWithContext('warn', nodeName, 'Processing with upstream error', {\n      upstreamError: inputData.message\n    });\n  }\n\n  const geminiResponse = inputData.geminiResponse;\n  const originalEmail = inputData.originalEmail;\n\n  // Extract the generated text from Gemini response with comprehensive error handling\n  let generatedResponse = '';\n  try {\n    if (geminiResponse && \n        geminiResponse.candidates && \n        geminiResponse.candidates[0] && \n        geminiResponse.candidates[0].content && \n        geminiResponse.candidates[0].content.parts && \n        geminiResponse.candidates[0].content.parts[0]) {\n      \n      generatedResponse = geminiResponse.candidates[0].content.parts[0].text || '';\n      \n      if (!generatedResponse.trim()) {\n        throw new Error('Empty response from Gemini API');\n      }\n      \n      logWithContext('info', nodeName, 'Successfully extracted Gemini response', {\n        responseLength: generatedResponse.length\n      });\n      \n    } else {\n      throw new Error('Invalid Gemini response structure');\n    }\n  } catch (error) {\n    logWithContext('error', nodeName, 'Error extracting Gemini response', {\n      error: error.message,\n      responseStructure: sanitizeForLogging(geminiResponse)\n    });\n    generatedResponse = 'I apologize, but I encountered an issue generating a response. Please reply manually to this email.';\n  }\n\n  // Clean up the response\n  try {\n    generatedResponse = generatedResponse.trim();\n    \n    // Remove any potential sensitive information that might have leaked\n    const sensitivePatterns = [\n      /api[_-]?key[s]?\\s*[:=]\\s*['\"]?[a-zA-Z0-9_-]+['\"]?/gi,\n      /token[s]?\\s*[:=]\\s*['\"]?[a-zA-Z0-9_-]+['\"]?/gi,\n      /password[s]?\\s*[:=]\\s*['\"]?[^\\s'\"]+['\"]?/gi\n    ];\n    \n    sensitivePatterns.forEach(pattern => {\n      if (pattern.test(generatedResponse)) {\n        logWithContext('warn', nodeName, 'Potential sensitive data detected in response, sanitizing');\n        generatedResponse = generatedResponse.replace(pattern, '[REDACTED]');\n      }\n    });\n    \n  } catch (error) {\n    logWithContext('warn', nodeName, 'Error cleaning response text', {\n      error: error.message\n    });\n  }\n\n  // Add attachment note if large attachments were skipped (requirement 1.6)\n  if (originalEmail && originalEmail.hasLargeAttachments) {\n    generatedResponse += '\\n\\nNote: Attachments from the original email were omitted from this response.';\n    logWithContext('info', nodeName, 'Added attachment omission note to response');\n  }\n\n  // Update token tracking\n  let tokenInfo = inputData.tokenInfo || {};\n  try {\n    const tokenTracker = new TokenTracker();\n    const updatedTokenInfo = tokenTracker.checkAndUpdateTokens(\n      inputData.geminiPrompt || '', \n      generatedResponse\n    );\n    tokenInfo = { ...tokenInfo, ...updatedTokenInfo };\n  } catch (error) {\n    logWithContext('warn', nodeName, 'Error updating token tracking', {\n      error: error.message\n    });\n  }\n\n  // Prepare SMS notification content with error handling\n  let smsMessage = '';\n  try {\n    const senderName = originalEmail?.from?.name || 'Unknown Sender';\n    const subject = originalEmail?.subject || 'No Subject';\n    \n    smsMessage = `New email draft ready:\\nFrom: ${senderName}\\nSubject: ${subject}`;\n    \n    if (originalEmail?.hasLargeAttachments) {\n      smsMessage += '\\n(Attachments omitted)';\n    }\n    \n    // Truncate SMS if too long\n    if (smsMessage.length > 160) {\n      smsMessage = smsMessage.substring(0, 157) + '...';\n      logWithContext('info', nodeName, 'SMS message truncated for length limit');\n    }\n    \n  } catch (error) {\n    logWithContext('error', nodeName, 'Error preparing SMS message', {\n      error: error.message\n    });\n    smsMessage = 'New email draft ready (details unavailable)';\n  }\n\n  logWithContext('info', nodeName, 'Response extraction completed successfully', {\n    messageId: originalEmail?.messageId,\n    responseLength: generatedResponse.length,\n    smsLength: smsMessage.length,\n    tokenInfo: tokenInfo\n  });\n\n  return {\n    json: {\n      originalEmail: originalEmail,\n      draftContent: generatedResponse,\n      smsMessage: smsMessage,\n      tokenInfo: tokenInfo,\n      extractionSuccess: true,\n      processedAt: new Date().toISOString(),\n      error: false\n    }\n  };\n\n} catch (error) {\n  const errorResponse = handleWorkflowError(error, 'Extract Gemini Response', {\n    inputData: sanitizeForLogging($input.all()[0]?.json)\n  });\n  \n  const inputData = $input.all()[0].json;\n  return {\n    json: {\n      ...errorResponse,\n      originalEmail: inputData.originalEmail || {\n        messageId: 'unknown',\n        subject: 'Error Processing',\n        from: { name: 'Unknown', address: 'unknown' }\n      },\n      draftContent: 'I apologize, but I encountered an error processing this email. Please reply manually.',\n      smsMessage: 'Email processing error - manual reply needed',\n      extractionSuccess: false,\n      processedAt: new Date().toISOString()\n    }\n  };\n}"
      },
      "id": "extract-response",
      "name": "Extract Gemini Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 300],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced Gmail Draft Creation with Database Retry Logic\n// Requirements: 5.1, 5.2, 5.3, 5.4, 5.5\n\nconst { logWithContext, retryDatabaseOperation, handleWorkflowError, sanitizeForLogging } = require('./error-handling-utils.js');\n\ntry {\n  const inputData = $input.all()[0].json;\n  const nodeName = 'Create Gmail Draft';\n  \n  logWithContext('info', nodeName, 'Starting Gmail draft creation', {\n    messageId: inputData.originalEmail?.messageId,\n    draftLength: inputData.draftContent?.length\n  });\n\n  // Check if previous nodes had errors\n  if (inputData.error && !inputData.extractionSuccess) {\n    logWithContext('warn', nodeName, 'Processing with upstream error', {\n      upstreamError: inputData.message\n    });\n  }\n\n  // Validate required data\n  if (!inputData.originalEmail || !inputData.draftContent) {\n    throw new Error('Missing required email or draft content data');\n  }\n\n  const originalEmail = inputData.originalEmail;\n  const draftContent = inputData.draftContent;\n\n  // Prepare draft data with error handling\n  let draftData;\n  try {\n    draftData = {\n      messageId: originalEmail.messageId,\n      subject: `Re: ${originalEmail.subject}`,\n      message: draftContent,\n      replyTo: originalEmail.from.address,\n      threadId: originalEmail.threadId\n    };\n    \n    // Validate draft data\n    if (!draftData.messageId || !draftData.subject || !draftData.message) {\n      throw new Error('Invalid draft data structure');\n    }\n    \n  } catch (error) {\n    logWithContext('error', nodeName, 'Error preparing draft data', {\n      error: error.message,\n      originalEmail: sanitizeForLogging(originalEmail)\n    });\n    throw error;\n  }\n\n  // The actual Gmail API call will be handled by the Gmail node\n  // This code node prepares the data and handles any preprocessing errors\n  \n  logWithContext('info', nodeName, 'Draft data prepared successfully', {\n    messageId: draftData.messageId,\n    subject: draftData.subject,\n    messageLength: draftData.message.length,\n    hasThreadId: !!draftData.threadId\n  });\n\n  return {\n    json: {\n      ...inputData,\n      draftData: draftData,\n      draftPreparationSuccess: true,\n      processedAt: new Date().toISOString(),\n      error: false\n    }\n  };\n\n} catch (error) {\n  const errorResponse = handleWorkflowError(error, 'Create Gmail Draft', {\n    inputData: sanitizeForLogging($input.all()[0]?.json)\n  });\n  \n  return {\n    json: {\n      ...$input.all()[0].json,\n      ...errorResponse,\n      draftPreparationSuccess: false,\n      processedAt: new Date().toISOString()\n    }\n  };\n}"
      },
      "id": "prepare-draft",
      "name": "Prepare Gmail Draft",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1120, 300],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "resource": "draft",
        "operation": "create",
        "messageId": "={{ $json.draftData?.messageId || $json.originalEmail?.messageId }}",
        "subject": "={{ $json.draftData?.subject || ('Re: ' + $json.originalEmail?.subject) }}",
        "message": "={{ $json.draftData?.message || $json.draftContent }}",
        "replyTo": "={{ $json.draftData?.replyTo || $json.originalEmail?.from?.address }}",
        "options": {
          "threadId": "={{ $json.draftData?.threadId || $json.originalEmail?.threadId }}"
        }
      },
      "id": "create-draft",
      "name": "Create Gmail Draft",
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [1340, 300],
      "credentials": {
        "gmailOAuth2": {
          "id": "gmail-oauth",
          "name": "Gmail OAuth"
        }
      },
      "onError": "continueRegularOutput",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Enhanced SMS Rate Limiting with Comprehensive Error Handling\n// Requirements: 5.1, 5.2, 5.3, 5.4, 5.5\n\nconst { logWithContext, handleWorkflowError, sanitizeForLogging, retryDatabaseOperation } = require('./error-handling-utils.js');\n\ntry {\n  const inputData = $input.all()[0].json;\n  const nodeName = 'SMS Rate Limit Check';\n  \n  logWithContext('info', nodeName, 'Starting SMS rate limit validation', {\n    messageId: inputData.originalEmail?.messageId\n  });\n\n  // Check if draft creation failed\n  let draftCreated = true;\n  if (inputData.error && !inputData.draftPreparationSuccess) {\n    logWithContext('warn', nodeName, 'Draft creation may have failed, continuing with SMS check', {\n      upstreamError: inputData.message\n    });\n    draftCreated = false;\n  }\n\n  const originalEmail = inputData.originalEmail;\n  const smsMessage = inputData.smsMessage;\n\n  // Get rate limiting configuration with validation\n  let dailyLimit, perRunLimit;\n  try {\n    dailyLimit = parseInt(process.env.SMS_DAILY_LIMIT || '50');\n    perRunLimit = parseInt(process.env.SMS_PER_RUN_LIMIT || '3');\n    \n    if (isNaN(dailyLimit) || dailyLimit <= 0) {\n      throw new Error('Invalid SMS_DAILY_LIMIT configuration');\n    }\n    if (isNaN(perRunLimit) || perRunLimit <= 0) {\n      throw new Error('Invalid SMS_PER_RUN_LIMIT configuration');\n    }\n    \n  } catch (error) {\n    logWithContext('error', nodeName, 'Invalid SMS limit configuration', {\n      error: error.message,\n      dailyLimitEnv: process.env.SMS_DAILY_LIMIT,\n      perRunLimitEnv: process.env.SMS_PER_RUN_LIMIT\n    });\n    throw error;\n  }\n\n  const userPhone = process.env.USER_PHONE_NUMBER;\n\n  // Check if user phone is configured (requirement 3.6)\n  if (!userPhone) {\n    logWithContext('info', nodeName, 'SMS notification skipped - USER_PHONE_NUMBER not configured', {\n      messageId: originalEmail?.messageId,\n      subject: originalEmail?.subject\n    });\n    \n    return {\n      json: {\n        ...inputData,\n        shouldSend: false,\n        reason: 'USER_PHONE_NUMBER not configured',\n        rateLimitInfo: {\n          dailyLimit: dailyLimit,\n          perRunLimit: perRunLimit,\n          currentCount: 0\n        },\n        draftCreated: draftCreated,\n        processedAt: new Date().toISOString(),\n        error: false\n      }\n    };\n  }\n\n  // Get current date for daily tracking with database retry\n  const today = new Date().toISOString().split('T')[0];\n  const storageKey = `sms_count_${today}`;\n\n  let dailyCount = 0;\n  try {\n    // Use database retry mechanism for workflow memory access\n    dailyCount = await retryDatabaseOperation(async () => {\n      const stored = $workflow.getStaticData('global')[storageKey];\n      return stored ? parseInt(stored) : 0;\n    }, 'get SMS daily count');\n    \n    if (isNaN(dailyCount) || dailyCount < 0) {\n      logWithContext('warn', nodeName, 'Invalid daily count retrieved, resetting to 0');\n      dailyCount = 0;\n    }\n    \n  } catch (error) {\n    logWithContext('warn', nodeName, 'Could not retrieve daily SMS count, starting from 0', {\n      error: error.message\n    });\n    dailyCount = 0;\n  }\n\n  // Check daily limit (requirement 3.3)\n  if (dailyCount >= dailyLimit) {\n    logWithContext('warn', nodeName, 'Daily SMS limit reached', {\n      dailyCount: dailyCount,\n      dailyLimit: dailyLimit,\n      messageId: originalEmail?.messageId\n    });\n    \n    return {\n      json: {\n        ...inputData,\n        shouldSend: false,\n        reason: 'Daily SMS limit reached',\n        rateLimitInfo: {\n          dailyLimit: dailyLimit,\n          perRunLimit: perRunLimit,\n          currentCount: dailyCount\n        },\n        draftCreated: draftCreated,\n        processedAt: new Date().toISOString(),\n        error: false\n      }\n    };\n  }\n\n  // Update daily count with database retry\n  const newDailyCount = dailyCount + 1;\n  try {\n    await retryDatabaseOperation(async () => {\n      $workflow.getStaticData('global')[storageKey] = newDailyCount.toString();\n      return true;\n    }, 'update SMS daily count');\n  } catch (error) {\n    logWithContext('error', nodeName, 'Could not update daily SMS count', {\n      error: error.message\n    });\n    // Continue anyway - this is not critical enough to stop the workflow\n  }\n\n  // Validate SMS message content\n  let validatedSmsMessage = smsMessage;\n  try {\n    if (!smsMessage || typeof smsMessage !== 'string') {\n      throw new Error('Invalid SMS message content');\n    }\n    \n    // Ensure message is not too long\n    if (smsMessage.length > 160) {\n      validatedSmsMessage = smsMessage.substring(0, 157) + '...';\n      logWithContext('info', nodeName, 'SMS message truncated for length');\n    }\n    \n  } catch (error) {\n    logWithContext('error', nodeName, 'Error validating SMS message', {\n      error: error.message\n    });\n    validatedSmsMessage = `Draft ready: ${originalEmail?.subject || 'Email'}`;\n  }\n\n  logWithContext('info', nodeName, 'SMS notification approved', {\n    messageId: originalEmail?.messageId,\n    dailyCount: newDailyCount,\n    dailyLimit: dailyLimit,\n    userPhone: userPhone.replace(/.(?=.{4})/g, '*'),\n    draftCreated: draftCreated\n  });\n\n  return {\n    json: {\n      ...inputData,\n      shouldSend: true,\n      smsMessage: validatedSmsMessage,\n      userPhone: userPhone,\n      rateLimitInfo: {\n        dailyLimit: dailyLimit,\n        perRunLimit: perRunLimit,\n        currentCount: newDailyCount\n      },\n      draftCreated: draftCreated,\n      processedAt: new Date().toISOString(),\n      error: false\n    }\n  };\n\n} catch (error) {\n  const errorResponse = handleWorkflowError(error, 'SMS Rate Limit Check', {\n    inputData: sanitizeForLogging($input.all()[0]?.json)\n  });\n  \n  return {\n    json: {\n      ...$input.all()[0].json,\n      ...errorResponse,\n      shouldSend: false,\n      reason: `Error in rate limiting: ${error.message}`,\n      processedAt: new Date().toISOString()\n    }\n  };\n}"
      },
      "id": "sms-rate-limit",
      "name": "SMS Rate Limit Check",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 300],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "should-send-sms",
              "leftValue": "={{ $json.shouldSend }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        }
      },
      "id": "sms-gate",
      "name": "SMS Rate Limit Gate",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1780, 300],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "message": "={{ $json.smsMessage }}",
        "toPhoneNumber": "={{ $json.userPhone }}",
        "fromPhoneNumber": "={{ $env.TWILIO_FROM_NUMBER }}",
        "options": {
          "statusCallback": ""
        }
      },
      "id": "send-sms",
      "name": "Send SMS Notification",
      "type": "n8n-nodes-base.twilio",
      "typeVersion": 1,
      "position": [2000, 200],
      "credentials": {
        "twilioApi": {
          "id": "twilio-api",
          "name": "Twilio API"
        }
      },
      "onError": "continueRegularOutput",
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Enhanced SMS Success Logging\n// Requirements: 5.1, 5.2, 5.3, 5.4, 5.5\n\nconst { logWithContext, sanitizeForLogging } = require('./error-handling-utils.js');\n\ntry {\n  const inputData = $input.all()[0].json;\n  const nodeName = 'Log SMS Success';\n  \n  // Check if SMS was actually sent successfully\n  const smsSuccess = !inputData.error && inputData.sid; // Twilio returns SID on success\n  \n  if (smsSuccess) {\n    logWithContext('info', nodeName, 'SMS notification sent successfully', {\n      messageId: inputData.originalEmail?.messageId,\n      smsSid: inputData.sid,\n      rateLimitInfo: inputData.rateLimitInfo,\n      draftCreated: inputData.draftCreated\n    });\n  } else {\n    logWithContext('error', nodeName, 'SMS notification failed', {\n      messageId: inputData.originalEmail?.messageId,\n      error: inputData.error || 'Unknown SMS error',\n      rateLimitInfo: inputData.rateLimitInfo,\n      draftCreated: inputData.draftCreated\n    });\n  }\n\n  return {\n    json: {\n      workflowCompleted: true,\n      smsSuccess: smsSuccess,\n      draftCreated: inputData.draftCreated,\n      messageId: inputData.originalEmail?.messageId,\n      completedAt: new Date().toISOString(),\n      error: false\n    }\n  };\n\n} catch (error) {\n  logWithContext('error', 'Log SMS Success', 'Error in SMS success logging', {\n    error: error.message,\n    inputData: sanitizeForLogging($input.all()[0]?.json)\n  });\n  \n  return {\n    json: {\n      workflowCompleted: true,\n      smsSuccess: false,\n      error: true,\n      message: error.message,\n      completedAt: new Date().toISOString()\n    }\n  };\n}"
      },
      "id": "log-sms-success",
      "name": "Log SMS Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2220, 200],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced SMS Skip Logging\n// Requirements: 5.1, 5.2, 5.3, 5.4, 5.5\n\nconst { logWithContext, sanitizeForLogging } = require('./error-handling-utils.js');\n\ntry {\n  const inputData = $input.all()[0].json;\n  const nodeName = 'Log SMS Skip';\n  \n  const rateLimitInfo = inputData.rateLimitInfo;\n  const reason = inputData.reason;\n\n  logWithContext('info', nodeName, 'SMS notification skipped', {\n    messageId: inputData.originalEmail?.messageId,\n    reason: reason,\n    currentCount: rateLimitInfo?.currentCount,\n    perRunLimit: rateLimitInfo?.perRunLimit,\n    dailyLimit: rateLimitInfo?.dailyLimit,\n    draftCreated: inputData.draftCreated\n  });\n\n  return {\n    json: {\n      workflowCompleted: true,\n      smsSkipped: true,\n      reason: reason,\n      rateLimitInfo: rateLimitInfo,\n      draftCreated: inputData.draftCreated,\n      messageId: inputData.originalEmail?.messageId,\n      completedAt: new Date().toISOString(),\n      error: false\n    }\n  };\n\n} catch (error) {\n  logWithContext('error', 'Log SMS Skip', 'Error in SMS skip logging', {\n    error: error.message,\n    inputData: sanitizeForLogging($input.all()[0]?.json)\n  });\n  \n  return {\n    json: {\n      workflowCompleted: true,\n      smsSkipped: true,\n      error: true,\n      message: error.message,\n      completedAt: new Date().toISOString()\n    }\n  };\n}"
      },
      "id": "log-sms-skip",
      "name": "Log SMS Skip",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2000, 400],
      "onError": "continueRegularOutput"
    }
  ],
  "connections": {
    "Gmail Trigger": {
      "main": [
        [
          {
            "node": "Process Email Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Email Content": {
      "main": [
        [
          {
            "node": "Gemini API Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Gemini API Request": {
      "main": [
        [
          {
            "node": "Extract Gemini Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Gemini Response": {
      "main": [
        [
          {
            "node": "Prepare Gmail Draft",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Gmail Draft": {
      "main": [
        [
          {
            "node": "Create Gmail Draft",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Gmail Draft": {
      "main": [
        [
          {
            "node": "SMS Rate Limit Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SMS Rate Limit Check": {
      "main": [
        [
          {
            "node": "SMS Rate Limit Gate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SMS Rate Limit Gate": {
      "main": [
        [
          {
            "node": "Send SMS Notification",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Log SMS Skip",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send SMS Notification": {
      "main": [
        [
          {
            "node": "Log SMS Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "",
    "timezone": "America/New_York"
  },
  "versionId": "2",
  "meta": {
    "templateCredsSetupCompleted": false
  },
  "id": "gmail-gemini-sms-workflow-enhanced",
  "tags": [
    {
      "createdAt": "2025-01-26T00:00:00.000Z",
      "updatedAt": "2025-01-26T00:00:00.000Z",
      "id": "pulse-ai-enhanced",
      "name": "pulse-ai-enhanced"
    }
  ]
}